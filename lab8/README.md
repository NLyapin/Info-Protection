# Лабораторная работа №8 - Электронная подпись RSA

## Описание алгоритма

Алгоритм электронной подписи RSA основан на том же математическом принципе, что и шифр RSA, но используется в обратном порядке для создания цифровой подписи.

### Принцип работы

1. **Генерация ключей** (аналогично RSA):
   - Выбираются два простых числа `p` и `q`
   - Вычисляется `n = p * q` и `φ(n) = (p-1) * (q-1)`
   - Выбирается открытый ключ `e` (взаимно простое с φ(n))
   - Вычисляется секретный ключ `d` (обратный к e по модулю φ(n))

2. **Подписание**:
   - Вычисляется хеш сообщения `H = SHA256(M)`
   - Каждый байт хеша подписывается: `s_i = h_i^d mod n`
   - Подпись состоит из массива подписей `(s_1, s_2, ..., s_n)`

3. **Проверка подписи**:
   - Вычисляется хеш сообщения `H' = SHA256(M)`
   - Для каждой подписи: `h'_i = s_i^e mod n`
   - Подпись корректна, если `H = H'`

### Математические формулы

- `n = p * q` (модуль)
- `φ(n) = (p-1) * (q-1)` (функция Эйлера)
- `e * d ≡ 1 (mod φ(n))` (связь ключей)
- `s_i = h_i^d mod n` (подписание байта)
- `h'_i = s_i^e mod n` (проверка подписи)

## Пример работы алгоритма

### Простой пример

```python
# Параметры
p = 3, q = 11
n = 33, φ(n) = 20
e = 3, d = 7

# Сообщение
M = "Hello"
H = SHA256("Hello") = [65, 66, 67, 97, 98, 99, ...]  # байты хеша

# Подписание
s_1 = 65^7 mod 33 = 27512614111 mod 33 = 32
s_2 = 66^7 mod 33 = 31640625216 mod 33 = 0
s_3 = 67^7 mod 33 = 36028797019 mod 33 = 1
# ... и так далее для каждого байта

# Проверка подписи
h'_1 = 32^3 mod 33 = 32768 mod 33 = 65 ✓
h'_2 = 0^3 mod 33 = 0 mod 33 = 0 ≠ 66 ✗
h'_3 = 1^3 mod 33 = 1 mod 33 = 1 ≠ 67 ✗
```

### Реальный пример с большими числами

```python
# Параметры
p = 1000000007, q = 1000000009
n = 1000000016000000063
φ(n) = 1000000006 * 1000000008
e = 65537, d = e^(-1) mod φ(n)

# Сообщение
M = "Важное сообщение"
H = SHA256(M) = [0x1a, 0x2b, 0x3c, ...]  # 32 байта

# Подписание каждого байта
for i, h_byte in enumerate(H):
    s_i = h_byte^d mod n
    # Сохраняем подпись

# Проверка подписи
for i, s_i in enumerate(signatures):
    h'_i = s_i^e mod n
    if h'_i != H[i]:
        return False  # Подпись неверна
return True  # Подпись корректна
```

## Запуск программы

```bash
# Демонстрация
python lab8.py --mode demo

# Подписание файла
python lab8.py --mode sign --input file.txt --signature file.sig

# Проверка подписи
python lab8.py --mode verify --input file.txt --signature file.sig
```

## Особенности реализации

- Использование SHA-256 (не слабее MD5)
- Подпись каждого байта хеша отдельно
- Сохранение подписей в отдельные файлы
- Поддержка больших чисел
- Автоматическая генерация ключей
