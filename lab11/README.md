# Лабораторная работа №11 - Электронная подпись FIPS 186 (DSA)

## Описание алгоритма

DSA (Digital Signature Algorithm) - это американский стандарт электронной цифровой подписи, определенный в FIPS 186. Алгоритм основан на проблеме дискретного логарифма и использует простое число `p`, простое число `q` (делитель p-1) и элемент `g` порядка q.

### Принцип работы

1. **Генерация ключей**:
   - Выбирается простое число `p` и простое число `q` такое, что `q | (p-1)`
   - Выбирается элемент `g` порядка `q` по модулю `p`
   - Генерируется секретный ключ `x` (случайное число от 1 до q-1)
   - Вычисляется открытый ключ `y = g^x mod p`

2. **Подписание**:
   - Вычисляется хеш сообщения `H = SHA256(M)`
   - Для каждого байта хеша `h_i`:
     - Выбирается случайное `k` (от 1 до q-1)
     - `r = (g^k mod p) mod q`
     - `s = k^(-1) * (h_i + x*r) mod q`
     - Подпись: `(r, s)`

3. **Проверка подписи**:
   - Вычисляется хеш сообщения `H' = SHA256(M)`
   - Для каждой подписи `(r, s)`:
     - `w = s^(-1) mod q`
     - `u1 = (h'_i * w) mod q`
     - `u2 = (r * w) mod q`
     - `v = (g^u1 * y^u2 mod p) mod q`
     - Подпись корректна, если `v = r`

### Математические формулы

- `y = g^x mod p` (открытый ключ)
- `r = (g^k mod p) mod q` (первая часть подписи)
- `s = k^(-1) * (h + x*r) mod q` (вторая часть подписи)
- `g^h ≡ g^(h*w) * y^(r*w) (mod p)` (проверка)

## Пример работы алгоритма

### Простой пример

```python
# Параметры
p = 7          # простое число
q = 3          # простое число, q | (p-1)
g = 2          # элемент порядка 3
x = 2          # секретный ключ
h = 1          # байт хеша

# Вычисляем открытый ключ
y = 2^2 mod 7 = 4

# Подписание
k = 1          # случайное число
r = (2^1 mod 7) mod 3 = 2 mod 3 = 2
k_inv = 1^(-1) mod 3 = 1  # 1 * 1 = 1 ≡ 1 mod 3
s = 1 * (1 + 2 * 2) mod 3 = 1 * 5 mod 3 = 5 mod 3 = 2

# Проверка подписи
s_inv = 2^(-1) mod 3 = 2  # 2 * 2 = 4 ≡ 1 mod 3
w = 2
u1 = (1 * 2) mod 3 = 2
u2 = (2 * 2) mod 3 = 4 mod 3 = 1
v = (2^2 * 4^1 mod 7) mod 3 = (4 * 4 mod 7) mod 3 = 16 mod 7 mod 3 = 2 mod 3 = 2
# v = 2 = r, подпись корректна ✓
```

### Реальный пример с большими числами

```python
# Параметры
p = 1000000007  # большое простое число
q = 500000003   # простое число, q | (p-1)
g = 2           # элемент порядка q
x = 123456789   # секретный ключ

# Вычисляем открытый ключ
y = pow(g, x, p)

# Подписание
for h_byte in hash_bytes:
    k = random.randint(1, q-1)
    r = pow(g, k, p) % q
    k_inv = pow(k, -1, q)
    s = (k_inv * (h_byte + x * r)) % q
    signatures.append((r, s))

# Проверка подписи
for (r, s), h_byte in zip(signatures, hash_bytes):
    s_inv = pow(s, -1, q)
    w = s_inv
    u1 = (h_byte * w) % q
    u2 = (r * w) % q
    v = (pow(g, u1, p) * pow(y, u2, p)) % p % q
    if v != r:
        return False  # Подпись неверна
return True  # Подпись корректна
```

## Запуск программы

```bash
# Демонстрация
python lab11.py --mode demo

# Подписание файла
python lab11.py --mode sign --input file.txt --signature file.sig

# Проверка подписи
python lab11.py --mode verify --input file.txt --signature file.sig
```

## Особенности реализации

- Поиск простых чисел q, делящих p-1
- Автоматический поиск элементов порядка q
- SHA-256 для хеширования
- Подпись каждого байта хеша отдельно
- Соблюдение американского стандарта FIPS 186
