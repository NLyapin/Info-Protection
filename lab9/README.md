# Лабораторная работа №9 - Электронная подпись Эль-Гамаля

## Описание алгоритма

Алгоритм электронной подписи Эль-Гамаля основан на проблеме дискретного логарифма и использует простое число `p`, первообразный корень `g` и секретный ключ `x`.

### Принцип работы

1. **Генерация ключей**:
   - Выбирается простое число `p` и первообразный корень `g`
   - Генерируется секретный ключ `x` (случайное число от 2 до p-2)
   - Вычисляется открытый ключ `y = g^x mod p`

2. **Подписание**:
   - Вычисляется хеш сообщения `H = SHA256(M)`
   - Для каждого байта хеша `h_i`:
     - Выбирается случайное `k` (взаимно простое с p-1)
     - `r = g^k mod p`
     - `s = k^(-1) * (h_i - x*r) mod (p-1)`
     - Подпись: `(r, s)`

3. **Проверка подписи**:
   - Вычисляется хеш сообщения `H' = SHA256(M)`
   - Для каждой подписи `(r, s)`:
     - `v = g^h'_i mod p`
     - `u = y^r * r^s mod p`
     - Подпись корректна, если `v = u`

### Математические формулы

- `y = g^x mod p` (открытый ключ)
- `r = g^k mod p` (случайный элемент)
- `s = k^(-1) * (h - x*r) mod (p-1)` (подпись)
- `g^h ≡ y^r * r^s (mod p)` (проверка)

## Пример работы алгоритма

### Простой пример

```python
# Параметры
p = 7          # простое число
g = 3          # первообразный корень
x = 4          # секретный ключ
h = 5          # байт хеша

# Вычисляем открытый ключ
y = 3^4 mod 7 = 81 mod 7 = 4

# Подписание
k = 5          # случайное число
r = 3^5 mod 7 = 243 mod 7 = 5
k_inv = 5^(-1) mod 6 = 5  # 5 * 5 = 25 ≡ 1 mod 6
s = 5 * (5 - 4*5) mod 6 = 5 * (5-20) mod 6 = 5 * (-15) mod 6 = 5 * 3 mod 6 = 15 mod 6 = 3

# Проверка подписи
v = 3^5 mod 7 = 243 mod 7 = 5
u = (4^5 * 5^3) mod 7 = (1024 * 125) mod 7 = 128000 mod 7 = 2
# 5 ≠ 2, подпись неверна (в данном примере)
```

### Реальный пример с большими числами

```python
# Параметры
p = 1000000007  # большое простое число
g = 2           # первообразный корень
x = 123456789   # секретный ключ

# Вычисляем открытый ключ
y = 2^123456789 mod 1000000007

# Подписание
for h_byte in hash_bytes:
    k = random.randint(2, p-2)
    while gcd(k, p-1) != 1:
        k = random.randint(2, p-2)
    
    r = pow(g, k, p)
    k_inv = pow(k, -1, p-1)
    s = (k_inv * (h_byte - x * r)) % (p-1)
    
    signatures.append((r, s))

# Проверка подписи
for (r, s), h_byte in zip(signatures, hash_bytes):
    v = pow(g, h_byte, p)
    u = (pow(y, r, p) * pow(r, s, p)) % p
    if v != u:
        return False  # Подпись неверна
return True  # Подпись корректна
```

## Запуск программы

```bash
# Демонстрация
python lab9.py --mode demo

# Подписание файла
python lab9.py --mode sign --input file.txt --signature file.sig

# Проверка подписи
python lab9.py --mode verify --input file.txt --signature file.sig
```

## Особенности реализации

- Использование безопасных простых чисел
- Автоматический поиск первообразных корней
- SHA-256 для хеширования
- Подпись каждого байта хеша отдельно
- Проверка взаимной простоты k и p-1
