# Лабораторная работа №3 - Протокол Диффи-Хеллмана

## Описание алгоритма

Протокол Диффи-Хеллмана - это криптографический протокол, позволяющий двум сторонам обмениваться секретным ключом по незащищенному каналу связи. Основан на проблеме дискретного логарифма.

### Принцип работы

Две стороны (Алиса и Боб) совместно выбирают общие параметры, затем каждая генерирует свой секретный ключ и вычисляет открытый ключ. После обмена открытыми ключами каждая сторона может вычислить общий секретный ключ.

### Алгоритм

1. **Выбор общих параметров**:
   - Простое число `p` (модуль)
   - Первообразный корень `g` по модулю `p`

2. **Генерация ключей**:
   - Алиса выбирает секретный ключ `xa` (случайное число от 2 до p-2)
   - Боб выбирает секретный ключ `xb` (случайное число от 2 до p-2)
   - Алиса вычисляет открытый ключ `ya = g^xa mod p`
   - Боб вычисляет открытый ключ `yb = g^xb mod p`

3. **Обмен открытыми ключами**:
   - Алиса отправляет `ya` Бобу
   - Боб отправляет `yb` Алисе

4. **Вычисление общего ключа**:
   - Алиса вычисляет `K = yb^xa mod p`
   - Боб вычисляет `K = ya^xb mod p`

### Математические формулы

- `ya = g^xa mod p` (открытый ключ Алисы)
- `yb = g^xb mod p` (открытый ключ Боба)
- `K = yb^xa mod p = ya^xb mod p` (общий секретный ключ)
- `K = g^(xa * xb) mod p` (математическая эквивалентность)

## Пример работы алгоритма

### Простой пример

```python
# Общие параметры
p = 7          # простое число
g = 3          # первообразный корень по модулю 7

# Секретные ключи
xa = 4         # секретный ключ Алисы
xb = 5         # секретный ключ Боба

# Вычисление открытых ключей
ya = 3^4 mod 7 = 81 mod 7 = 4    # открытый ключ Алисы
yb = 3^5 mod 7 = 243 mod 7 = 5   # открытый ключ Боба

# Обмен открытыми ключами
# Алиса отправляет ya=4 Бобу
# Боб отправляет yb=5 Алисе

# Вычисление общего ключа
K_alice = 5^4 mod 7 = 625 mod 7 = 2    # Алиса вычисляет
K_bob = 4^5 mod 7 = 1024 mod 7 = 2    # Боб вычисляет

# Результат: K_alice = K_bob = 2 ✓
# Общий секретный ключ: 2
```

### Реальный пример с большими числами

```python
# Общие параметры
p = 1000000007  # большое простое число
g = 2           # первообразный корень

# Секретные ключи
xa = 123456789  # секретный ключ Алисы
xb = 987654321  # секретный ключ Боба

# Вычисление открытых ключей
ya = pow(2, 123456789, 1000000007)  # открытый ключ Алисы
yb = pow(2, 987654321, 1000000007)  # открытый ключ Боба

# Вычисление общего ключа
K_alice = pow(yb, 123456789, 1000000007)
K_bob = pow(ya, 987654321, 1000000007)

# Результат: K_alice = K_bob
# Общий секретный ключ: большое число < 1000000007
```

## Генерация безопасных параметров

### Безопасные простые числа

```python
def gen_safe_prime(bits=32):
    """Генерация безопасного простого p = 2*q + 1"""
    while True:
        q = gen_probable_prime(bits - 1)
        p = 2 * q + 1
        if is_probable_prime_fermat(p):
            return p, q

# Пример
p, q = gen_safe_prime(32)
print(f"Безопасное простое: p = {p}")
print(f"Софи Жермен: q = {q}")
print(f"Проверка: p = 2*q + 1 = {2*q + 1}")
```

### Поиск первообразных корней

```python
def find_primitive_root(p, q):
    """Поиск первообразного корня для безопасного простого p = 2q + 1"""
    for g in range(2, p):
        # Для безопасного простого p = 2q + 1:
        # g - первообразный корень, если g^2 ≠ 1 (mod p) и g^q ≠ 1 (mod p)
        if pow(g, 2, p) != 1 and pow(g, q, p) != 1:
            return g
    raise ValueError("Первообразный корень не найден")

# Пример
p = 7  # безопасное простое: 7 = 2*3 + 1
q = 3
g = find_primitive_root(p, q)
print(f"Первообразный корень по модулю {p}: g = {g}")

# Проверка
for i in range(1, p):
    print(f"g^{i} mod p = {pow(g, i, p)}")
```

## Детальная реализация протокола

### Полный протокол с проверками

```python
def diffie_hellman_protocol(p, g, xa, xb):
    """Полная реализация протокола Диффи-Хеллмана"""
    
    print("=== ПРОТОКОЛ ДИФФИ-ХЕЛЛМАНА ===")
    print(f"Общие параметры:")
    print(f"  p = {p}")
    print(f"  g = {g}")
    print()
    
    # Проверка параметров
    if not is_probable_prime_fermat(p):
        raise ValueError("p должно быть простым числом")
    
    if pow(g, p-1, p) != 1:
        raise ValueError("g должен быть первообразным корнем")
    
    # Генерация ключей
    print("Генерация ключей:")
    ya = pow(g, xa, p)
    yb = pow(g, xb, p)
    print(f"  Секретный ключ Алисы: xa = {xa}")
    print(f"  Секретный ключ Боба: xb = {xb}")
    print(f"  Открытый ключ Алисы: ya = {ya}")
    print(f"  Открытый ключ Боба: yb = {yb}")
    print()
    
    # Обмен ключами
    print("Обмен открытыми ключами:")
    print(f"  Алиса → Боб: ya = {ya}")
    print(f"  Боб → Алиса: yb = {yb}")
    print()
    
    # Вычисление общего ключа
    print("Вычисление общего ключа:")
    K_alice = pow(yb, xa, p)
    K_bob = pow(ya, xb, p)
    print(f"  Ключ Алисы: K = yb^xa mod p = {K_alice}")
    print(f"  Ключ Боба: K = ya^xb mod p = {K_bob}")
    print()
    
    # Проверка
    if K_alice == K_bob:
        print(f"✓ УСПЕХ: Общий ключ = {K_alice}")
    else:
        print("✗ ОШИБКА: Ключи не совпадают!")
    
    return K_alice
```

## Запуск программы

```bash
# Запуск с генерацией параметров
python3 lab3.py

# Программа предложит выбрать режим:
# 1. input - ввод параметров с клавиатуры
# 2. rand - автоматическая генерация параметров
```

## Безопасность протокола

### Атаки и защита

1. **Атака "человек посередине" (MITM)**:
   - Проблема: Злоумышленник может перехватывать и подменять ключи
   - Защита: Аутентификация участников (цифровые подписи, сертификаты)

2. **Атака по словарю**:
   - Проблема: Предсказуемые секретные ключи
   - Защита: Использование криптографически стойких генераторов случайных чисел

3. **Атака на слабые параметры**:
   - Проблема: Использование малых или предсказуемых p, g
   - Защита: Использование больших безопасных простых чисел

### Рекомендации по безопасности

```python
# Минимальные требования к параметрам
MIN_P_BITS = 2048  # Минимум 2048 бит для p
MIN_X_BITS = 256   # Минимум 256 бит для секретных ключей

def generate_secure_params():
    """Генерация криптографически стойких параметров"""
    # Генерируем безопасное простое число
    p, q = gen_safe_prime(MIN_P_BITS)
    
    # Находим первообразный корень
    g = find_primitive_root(p, q)
    
    # Генерируем секретные ключи
    xa = random.getrandbits(MIN_X_BITS)
    xb = random.getrandbits(MIN_X_BITS)
    
    return p, g, xa, xb
```

## Применение в криптографии

1. **Обмен ключами**: Основа для многих криптографических протоколов
2. **TLS/SSL**: Используется в протоколах безопасной связи
3. **VPN**: Защищенная передача данных
4. **Электронная почта**: Шифрование сообщений
5. **Блокчейн**: Генерация адресов и подписей

## Особенности реализации

- **Большие числа**: Поддержка чисел порядка 10! и больше
- **Безопасные параметры**: Использование безопасных простых чисел
- **Первообразные корни**: Автоматический поиск генераторов
- **Проверки**: Валидация всех параметров и результатов
- **Гибкость**: Поддержка как ручного ввода, так и автоматической генерации
