# Лабораторная работа №2 - Алгоритм "Шаг младенца, шаг великана"

## Описание алгоритма

Алгоритм "Шаг младенца, шаг великана" (Baby-step Giant-step) - это эффективный алгоритм для решения задачи дискретного логарифма. Он находит значение `x` в уравнении `y = a^x mod p` при известных `a`, `y`, `p`.

### Принцип работы

Алгоритм основан на идее разделения поиска на два этапа:
1. **Шаг младенца**: Предвычисление и сохранение значений `a^j mod p` для малых `j`
2. **Шаг великана**: Поиск совпадений с выражениями вида `y * a^(-mk) mod p`

### Алгоритм

1. Вычислить `m = ⌈√p⌉`
2. **Шаг младенца**: Создать таблицу `(a^j mod p, j)` для `j = 0, 1, ..., m-1`
3. **Шаг великана**: Для `k = 1, 2, ..., m`:
   - Вычислить `y * a^(-mk) mod p`
   - Найти это значение в таблице шага младенца
   - Если найдено, то `x = mk + j`

### Математические формулы

- `m = ⌈√p⌉` (размер шага)
- `a^j mod p` (шаг младенца, j = 0, 1, ..., m-1)
- `y * a^(-mk) mod p` (шаг великана, k = 1, 2, ..., m)
- `x = mk + j` (решение)

### Сложность

- **Время**: O(√p log p)
- **Память**: O(√p)

## Пример работы алгоритма

### Простой пример

```python
# Найти x в уравнении 4 = 5^x mod 7
y = 4, a = 5, p = 7

# Шаг 1: Вычисляем m
m = ⌈√7⌉ = ⌈2.645⌉ = 3

# Шаг 2: Шаг младенца - создаем таблицу
# j=0: 5^0 mod 7 = 1
# j=1: 5^1 mod 7 = 5  
# j=2: 5^2 mod 7 = 25 mod 7 = 4

# Таблица: [(1,0), (5,1), (4,2)]

# Шаг 3: Шаг великана
# Вычисляем a^(-m) mod p = 5^(-3) mod 7
# 5^(-3) mod 7 = 5^(7-1-3) mod 7 = 5^3 mod 7 = 125 mod 7 = 6

# k=1: y * a^(-mk) mod p = 4 * 6^1 mod 7 = 24 mod 7 = 3
# Ищем 3 в таблице - не найдено

# k=2: y * a^(-mk) mod p = 4 * 6^2 mod 7 = 4 * 36 mod 7 = 4 * 1 mod 7 = 4
# Ищем 4 в таблице - найдено! j=2
# x = mk + j = 3*2 + 2 = 8

# Проверка: 5^8 mod 7 = 390625 mod 7 = 4 ✓
```

### Реальный пример с большими числами

```python
# Найти x в уравнении 12345 = 2^x mod 1000000007
y = 12345
a = 2
p = 1000000007

# Шаг 1: Вычисляем m
m = ⌈√1000000007⌉ = ⌈31622.77⌉ = 31623

# Шаг 2: Шаг младенца
baby_steps = {}
for j in range(m):
    value = pow(a, j, p)
    baby_steps[value] = j
    if j < 5:  # Показываем первые 5 значений
        print(f"j={j}: 2^{j} mod {p} = {value}")

# Шаг 3: Шаг великана
a_m_inv = pow(pow(a, m, p), -1, p)  # a^(-m) mod p

for k in range(1, m+1):
    giant_step = (y * pow(a_m_inv, k, p)) % p
    if giant_step in baby_steps:
        j = baby_steps[giant_step]
        x = k * m + j
        print(f"Найдено решение: x = {x}")
        print(f"Проверка: {a}^{x} mod {p} = {pow(a, x, p)}")
        break
```

## Детальный разбор алгоритма

### Построение таблицы шага младенца

```python
def baby_step_giant_step(a, y, p):
    m = math.ceil(math.sqrt(p))
    
    # Шаг младенца: создаем таблицу
    baby_steps = {}
    for j in range(m):
        value = pow(a, j, p)
        baby_steps[value] = j
        print(f"Шаг младенца: a^{j} mod p = {value}")
    
    # Шаг великана: ищем совпадения
    a_m = pow(a, m, p)
    a_m_inv = pow(a_m, -1, p)
    
    for k in range(1, m+1):
        giant_step = (y * pow(a_m_inv, k, p)) % p
        print(f"Шаг великана: y * a^(-{m*k}) mod p = {giant_step}")
        
        if giant_step in baby_steps:
            j = baby_steps[giant_step]
            x = k * m + j
            return x
    
    return None  # Решение не найдено
```

### Оптимизация памяти

```python
# Для больших p можно использовать хеш-таблицу
def optimized_baby_step_giant_step(a, y, p):
    m = math.ceil(math.sqrt(p))
    
    # Используем словарь для O(1) поиска
    baby_steps = {}
    for j in range(m):
        value = pow(a, j, p)
        baby_steps[value] = j
    
    # Шаг великана
    a_m_inv = pow(pow(a, m, p), -1, p)
    
    for k in range(1, m+1):
        giant_step = (y * pow(a_m_inv, k, p)) % p
        if giant_step in baby_steps:
            return k * m + baby_steps[giant_step]
    
    return None
```

## Запуск программы

```bash
# Запуск с примером
python3 lab2.py

# Программа автоматически решает уравнение 4 = 5^x mod 7
```

## Особенности реализации

- **Эффективность**: Сложность O(√p log p) вместо O(p)
- **Память**: Требует O(√p) памяти для хранения таблицы
- **Универсальность**: Работает с любыми простыми числами
- **Точность**: Гарантированно находит решение, если оно существует

## Применение в криптографии

1. **Атаки на Диффи-Хеллман**: Взлом общих ключей
2. **Атаки на Эль-Гамаль**: Расшифровка сообщений
3. **Анализ стойкости**: Оценка безопасности криптографических систем
4. **Генерация ключей**: Проверка стойкости параметров

## Ограничения алгоритма

- **Требования к памяти**: Для очень больших p может потребоваться много памяти
- **Время выполнения**: Для больших p все еще может быть медленным
- **Применимость**: Эффективен только для простых чисел умеренного размера

## Сравнение с другими методами

| Метод | Сложность | Память | Применимость |
|-------|-----------|--------|--------------|
| Полный перебор | O(p) | O(1) | Малые p |
| Baby-step Giant-step | O(√p log p) | O(√p) | Средние p |
| Pollard's rho | O(√p) | O(1) | Большие p |
| Index calculus | O(exp(√log p log log p)) | O(√p) | Очень большие p |
