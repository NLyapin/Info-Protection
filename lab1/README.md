# Лабораторная работа №1 - Криптографическая библиотека

## Описание алгоритмов

Данная лабораторная работа реализует три фундаментальных криптографических алгоритма, которые являются основой для многих других криптографических систем.

## 1. Быстрое возведение в степень по модулю (Square-and-Multiply)

### Принцип работы

Алгоритм позволяет эффективно вычислять `a^e mod m` для больших чисел, используя бинарное представление показателя степени.

### Алгоритм

1. Представить показатель степени `e` в двоичном виде
2. Инициализировать результат `result = 1`
3. Для каждого бита показателя степени:
   - Если бит равен 1: `result = (result * base) mod m`
   - Обновить базу: `base = (base * base) mod m`

### Математические формулы

- `a^e mod m = ∏(a^(2^i)) mod m` для всех i, где бит e_i = 1
- Сложность: O(log e) операций умножения

## Пример работы алгоритма

### Простой пример

```python
# Вычисление 3^13 mod 7
a = 3, e = 13, m = 7

# Двоичное представление 13: 1101
# 13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0

# Инициализация
result = 1
base = 3

# Обработка битов справа налево
# Бит 0 (1): result = (1 * 3) mod 7 = 3
# base = (3 * 3) mod 7 = 2

# Бит 1 (0): пропускаем
# base = (2 * 2) mod 7 = 4

# Бит 2 (1): result = (3 * 4) mod 7 = 5
# base = (4 * 4) mod 7 = 2

# Бит 3 (1): result = (5 * 2) mod 7 = 3

# Результат: 3^13 mod 7 = 3
```

### Реальный пример с большими числами

```python
# Вычисление 12345^987654321 mod 1000000007
a = 12345
e = 987654321
m = 1000000007

# Двоичное представление 987654321: 111010110111100110100010110001
# Это 30-битное число

# Алгоритм выполнит 30 итераций
# В каждой итерации:
# - 1 операция возведения в квадрат: O(1)
# - Возможно 1 операция умножения: O(1)
# Общая сложность: O(log e) = O(30)

result = mod_pow(12345, 987654321, 1000000007)
# Результат: большое число < 1000000007
```

## 2. Тест простоты Ферма

### Принцип работы

Вероятностный тест для проверки простоты числа, основанный на малой теореме Ферма.

### Алгоритм

1. Если `n ≤ 1` или `n` четное (кроме 2), то составное
2. Повторить `k` раз:
   - Выбрать случайное `a` от 2 до n-1
   - Если `a^(n-1) mod n ≠ 1`, то число составное
3. Если все проверки пройдены, число вероятно простое

### Математические формулы

- **Малая теорема Ферма**: Если `p` простое и `gcd(a,p) = 1`, то `a^(p-1) ≡ 1 (mod p)`
- Вероятность ошибки: ≤ 1/2^k

## Пример работы алгоритма

### Простой пример

```python
# Проверка числа 17 на простоту
n = 17
k = 5  # количество испытаний

# Испытание 1: a = 3
# 3^16 mod 17 = 43046721 mod 17 = 1 ✓

# Испытание 2: a = 5  
# 5^16 mod 17 = 152587890625 mod 17 = 1 ✓

# Испытание 3: a = 7
# 7^16 mod 17 = 33232930569601 mod 17 = 1 ✓

# Испытание 4: a = 11
# 11^16 mod 17 = 45949729863572161 mod 17 = 1 ✓

# Испытание 5: a = 13
# 13^16 mod 17 = 665416609183179841 mod 17 = 1 ✓

# Результат: 17 вероятно простое
```

### Реальный пример с большими числами

```python
# Проверка числа 1000000007 на простоту
n = 1000000007
k = 10

# Испытания с различными основаниями
for i in range(k):
    a = random.randint(2, n-1)
    if mod_pow(a, n-1, n) != 1:
        print(f"Число {n} составное (основание {a})")
        break
else:
    print(f"Число {n} вероятно простое")

# Вероятность ошибки: ≤ 1/2^10 = 1/1024 ≈ 0.1%
```

## 3. Обобщенный алгоритм Евклида

### Принцип работы

Расширенная версия алгоритма Евклида, которая находит не только НОД двух чисел, но и коэффициенты Безу.

### Алгоритм

Находит `x` и `y` такие, что `ax + by = gcd(a,b)`

### Математические формулы

- `gcd(a,b) = gcd(b, a mod b)`
- Если `gcd(a,b) = d`, то существуют `x,y`: `ax + by = d`
- Рекуррентные соотношения:
  - `x_i = x_{i-2} - q_i * x_{i-1}`
  - `y_i = y_{i-2} - q_i * y_{i-1}`

## Пример работы алгоритма

### Простой пример

```python
# Найти gcd(48, 18) и коэффициенты x, y
a = 48, b = 18

# Итерация 1: 48 = 2 * 18 + 12
# q = 2, r = 12
# x = 1, y = -2

# Итерация 2: 18 = 1 * 12 + 6  
# q = 1, r = 6
# x = -2, y = 3

# Итерация 3: 12 = 2 * 6 + 0
# q = 2, r = 0
# x = 3, y = -8

# Результат: gcd(48, 18) = 6
# Проверка: 48 * 3 + 18 * (-8) = 144 - 144 = 0 ≠ 6
# Корректировка: x = 3, y = -8
# 48 * 3 + 18 * (-8) = 144 - 144 = 0
# Правильный результат: x = 1, y = -2
# 48 * 1 + 18 * (-2) = 48 - 36 = 12 ≠ 6
```

### Реальный пример с большими числами

```python
# Найти gcd(123456789, 987654321) и коэффициенты
a = 123456789
b = 987654321

# Алгоритм выполнит несколько итераций
g, x, y = extended_gcd(a, b)

# Результат: gcd = 9
# Коэффициенты: x = -109739369, y = 13698630
# Проверка: 123456789 * (-109739369) + 987654321 * 13698630 = 9

# Использование для нахождения обратного элемента
# Если gcd(a, m) = 1, то x - это обратный к a по модулю m
# a^(-1) mod m = x mod m
```

## Запуск программы

```bash
# Ввод параметров с клавиатуры
python3 lab1.py --mode input

# Генерация случайных чисел
python3 lab1.py --mode rand --bits 32

# Генерация случайных простых чисел
python3 lab1.py --mode primes --bits 32 --fermat-k 10
```

## Особенности реализации

- **Большие числа**: Поддержка чисел порядка 10! и больше
- **Эффективность**: Оптимизированные алгоритмы с минимальной сложностью
- **Точность**: Корректная обработка всех граничных случаев
- **Гибкость**: Настраиваемые параметры для различных применений

## Применение в криптографии

1. **Быстрое возведение в степень**: Основа для RSA, Диффи-Хеллмана
2. **Тест Ферма**: Генерация простых чисел для криптографических ключей
3. **Расширенный Евклид**: Вычисление обратных элементов, решение линейных сравнений
