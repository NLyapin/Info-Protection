# Лабораторная работа №10 - Электронная подпись ГОСТ Р 34.10-94

## Описание алгоритма

ГОСТ Р 34.10-94 - это российский стандарт электронной цифровой подписи, основанный на проблеме дискретного логарифма в конечном поле. Алгоритм использует простое число `p`, простое число `q` (делитель p-1) и элемент `a` порядка q.

### Принцип работы

1. **Генерация ключей**:
   - Выбирается простое число `p` и простое число `q` такое, что `q | (p-1)`
   - Выбирается элемент `a` порядка `q` по модулю `p`
   - Генерируется секретный ключ `x` (случайное число от 1 до q-1)
   - Вычисляется открытый ключ `y = a^x mod p`

2. **Подписание**:
   - Вычисляется хеш сообщения `H = SHA256(M)`
   - Для каждого байта хеша `h_i`:
     - Выбирается случайное `k` (от 1 до q-1)
     - `r = (a^k mod p) mod q`
     - `s = (k * h_i + x * r) mod q`
     - Подпись: `(r, s)`

3. **Проверка подписи**:
   - Вычисляется хеш сообщения `H' = SHA256(M)`
   - Для каждой подписи `(r, s)`:
     - `v = h'_i^(-1) mod q`
     - `z1 = (s * v) mod q`
     - `z2 = (r * v) mod q`
     - `u = (a^z1 * y^z2 mod p) mod q`
     - Подпись корректна, если `u = r`

### Математические формулы

- `y = a^x mod p` (открытый ключ)
- `r = (a^k mod p) mod q` (первая часть подписи)
- `s = (k * h + x * r) mod q` (вторая часть подписи)
- `a^h ≡ a^(s*v) * y^(r*v) (mod p)` (проверка)

## Пример работы алгоритма

### Простой пример

```python
# Параметры
p = 7          # простое число
q = 3          # простое число, q | (p-1), так как 6 = 2*3
a = 2          # элемент порядка 3 (2^3 = 8 ≡ 1 mod 7)
x = 2          # секретный ключ
h = 1          # байт хеша

# Вычисляем открытый ключ
y = 2^2 mod 7 = 4

# Подписание
k = 1          # случайное число
r = (2^1 mod 7) mod 3 = 2 mod 3 = 2
s = (1 * 1 + 2 * 2) mod 3 = (1 + 4) mod 3 = 5 mod 3 = 2

# Проверка подписи
h_inv = 1^(-1) mod 3 = 1  # 1 * 1 = 1 ≡ 1 mod 3
z1 = (2 * 1) mod 3 = 2
z2 = (2 * 1) mod 3 = 2
u = (2^2 * 4^2 mod 7) mod 3 = (4 * 16 mod 7) mod 3 = (4 * 2 mod 7) mod 3 = 8 mod 7 mod 3 = 1 mod 3 = 1
# u = 1 ≠ r = 2, подпись неверна
```

### Реальный пример с большими числами

```python
# Параметры
p = 1000000007  # большое простое число
q = 500000003   # простое число, q | (p-1)
a = 2           # элемент порядка q
x = 123456789   # секретный ключ

# Вычисляем открытый ключ
y = pow(a, x, p)

# Подписание
for h_byte in hash_bytes:
    k = random.randint(1, q-1)
    r = pow(a, k, p) % q
    s = (k * h_byte + x * r) % q
    signatures.append((r, s))

# Проверка подписи
for (r, s), h_byte in zip(signatures, hash_bytes):
    h_inv = pow(h_byte, -1, q)
    z1 = (s * h_inv) % q
    z2 = (r * h_inv) % q
    u = (pow(a, z1, p) * pow(y, z2, p)) % p % q
    if u != r:
        return False  # Подпись неверна
return True  # Подпись корректна
```

## Запуск программы

```bash
# Демонстрация
python lab10.py --mode demo

# Подписание файла
python lab10.py --mode sign --input file.txt --signature file.sig

# Проверка подписи
python lab10.py --mode verify --input file.txt --signature file.sig
```

## Особенности реализации

- Поиск простых чисел q, делящих p-1
- Автоматический поиск элементов порядка q
- SHA-256 для хеширования
- Подпись каждого байта хеша отдельно
- Соблюдение российского стандарта ГОСТ Р 34.10-94
